/***********************************************************************************************************************
 * File Name    : hal_entry.c
 * Description  : Contains data structures and functions used in hal_entry.c.
 **********************************************************************************************************************/
/*
 * Copyright (c) 2020 - 2024 Renesas Electronics Corporation and/or its affiliates
 * 
 * SPDX-License-Identifier: BSD-3-Clause
 */

#include "hal_data.h"
#include "pd_axi_on.h"
#include "i2c_pmic.h"
#include "pll_init.h"
#include "xspi_init.h"
#include "ca55_start.h"
#include "cr8_start.h"
#include "common_utils.h"
#include "poeg_ep.h"
#define MODULE_NAME		"r_poeg"

FSP_CPP_HEADER
void R_BSP_WarmStart(bsp_warm_start_event_t event);

FSP_CPP_FOOTER

/* Global variable */
uint8_t g_num_bytes = RESET_VALUE;
static volatile uint8_t g_interrupt_pin_trigger_flag = RESET_VALUE;
static volatile uint8_t g_interrupt_output_level_flag = RESET_VALUE;
static volatile uint8_t g_mode_flag = RESET_VALUE;

/* Board specific pin configuration. */
#define POEG_TEST_CONTROL_PIN               (BSP_IO_PORT_08_PIN_00)
/* Structure with LED information for board. */
const bsp_leds_t g_leds =
{
    .led_count = (uint16_t) ((sizeof(g_prv_leds)) / (sizeof(g_prv_leds[0]))),
    .p_leds    = &g_prv_leds[0]
};

/* User defined function */
static void led_pin_initialisation(void);

/*******************************************************************************************************************//**
 * main() is generated by the Configuration editor and is used to generate threads if an RTOS is used.  This function
 * is called by main() when no RTOS is used.
 **********************************************************************************************************************/
void hal_entry (void)
{
    fsp_err_t err = FSP_SUCCESS;
    fsp_pack_version_t version = {RESET_VALUE};

    /* Initialization of LED Pins*/
    led_pin_initialisation();

    /* version get API for FLEX pack information */
    R_FSP_VersionGet(&version);

    /* Example Project information printed on the Console */
    APP_PRINT(BANNER_INFO, EP_VERSION, version.version_id_b.major, version.version_id_b.minor, version.version_id_b.patch);
    R_BSP_SoftwareDelay(200, BSP_DELAY_UNITS_MILLISECONDS);
    APP_PRINT(EP_INFO);
    R_BSP_SoftwareDelay(200, BSP_DELAY_UNITS_MILLISECONDS);

    /* Initialize the POEG0 */
    err = init_poeg0_module();
    /* Handle error */
    if(FSP_SUCCESS != err)
    {
        APP_ERR_PRINT("\r\nPOEG0 initialization for GPT output level mode failed\r\n");
        APP_ERR_TRAP(err);
    }
    else
    {
        APP_PRINT("\r\nPOEG0 initialized successfully for GPT output level mode\r\n");
    }

    /* Initialize the POEG1 */
    err = init_poeg1_module();
    /* Handle error */
    if(FSP_SUCCESS != err)
    {
        APP_ERR_PRINT("\r\nPOEG1 initialization for GTETRG pin trigger and software api failed\r\n");
        APP_ERR_TRAP(err);
    }
    else
    {
        APP_PRINT("POEG1 initialized successfully for GTETRG pin trigger and software api\r\n");
    }

    /* Initialize the Timer1 in PWM mode */
    err = init_gpt_timer_pwm1();
    /* Handle error */
    if(FSP_SUCCESS != err)
    {
        APP_ERR_PRINT("\r\nTIMER1 start failed\r\n");
        /*Close PWM Timer instance */
        deinit_gpt_timer(&g_timer_pwm1_ctrl);
        APP_ERR_TRAP(err);
    }
    else
    {
        APP_PRINT("GPT Timer1 initialized successfully for PWM mode\r\n");
    }

    /* Initialize the Timer2 in PWM mode */
    err = init_gpt_timer_pwm2();
    /* Handle error */
    if(FSP_SUCCESS != err)
    {
        APP_ERR_PRINT("\r\nGPT TIMER2 start failed\r\n");
        deinit_gpt_timer(&g_timer_pwm2_ctrl);
        APP_ERR_TRAP(err);
    }
    else
    {
        APP_PRINT("GPT Timer2 initialized successfully for PWM mode\r\n");
    }

    while(true)
    {
        APP_PRINT(MENU_INFO);
        /* Process input only when User has provided one */
        while(!APP_CHECK_DATA);
        if (APP_CHECK_DATA)
        {
            poeg_ouput_disable_and_reset_options();
        }
    }
}

/*******************************************************************************************************************//**
 * @brief This function reads the command(input) for RTT and processes the command for poeg output disable.
 *
 * @param[in] None
 * @retval    FSP_SUCCESS                  Upon successful
 * @retval    Any Other Error code apart from FSP_SUCCESS  Upon Unsuccessful
 **********************************************************************************************************************/
fsp_err_t poeg_ouput_disable_and_reset_options(void)
{
    fsp_err_t err = FSP_SUCCESS;
    /* Variable to store user input */
    uint8_t rByte[BUFFER_SIZE_DOWN] = {NULL_CHAR};
    uint8_t converted_rtt_input = RESET_VALUE;

    APP_READ(rByte);
    /* User input selection */
    converted_rtt_input = (uint8_t)atoi((char *)rByte);

    switch (converted_rtt_input)
    {
        /* POEG_TRIGGER_ON_GTETRG_INPUT_PIN_LEVEL - Disables GPT output pins based
         * on GTETRG input pin level */
        case POEG_TRIGGER_ON_GTETRG_INPUT_PIN_LEVEL :
        {
            /* Start PWM Timer*/
            err = R_GPT_Start(&g_timer_pwm2_ctrl);
            /* Handle error */
            if (FSP_SUCCESS != err)
            {
                APP_ERR_PRINT ("\r\nR_GPT_Start API failed\r\n");
                return(err);
            }
            else
            {
                APP_PRINT("\r\nStarted Timer2 in PWM Mode\r\n");
            }
            APP_PRINT("Enter any Key to Disable GPT output using GTETRG trigger pin mode\r\n");
            while(true)
            {
                if (APP_CHECK_DATA)
                {
                    APP_READ(rByte);
                    break;
                }
            }
            g_mode_flag = POEG_TRIGGER_ON_GTETRG_INPUT_PIN_LEVEL;

            /* Set GTETRG to trigger POEG. */
            R_BSP_PinWrite(POEG_TEST_CONTROL_PIN, BSP_IO_LEVEL_LOW);

            /* Enable IRQ */
            R_BSP_IrqEnable(POEG_GROUP1_IRQn);
            while(!g_interrupt_pin_trigger_flag)
            {
                /* waiting for interrupt flag */
            }
            APP_PRINT("\r\nPOEG trigger on GTETRG input pin level successful\r\n");
            R_IOPORT_PinWrite(&g_ioport_ctrl, LED_PIN_POEG1, BSP_IO_LEVEL_HIGH);

            /* GTETRG inactive. */
            R_BSP_PinWrite(POEG_TEST_CONTROL_PIN, BSP_IO_LEVEL_HIGH);
            break;
        }

        /* POEG_OUTPUT_DISABLE_SOFTWARE_API - Disable GPT output pins using POEG software API */
        case POEG_OUTPUT_DISABLE_SOFTWARE_API:
        {
            /* Start PWM Timer */
            err = R_GPT_Start(&g_timer_pwm2_ctrl);
            /* Handle error */
            if (FSP_SUCCESS != err)
            {
                APP_ERR_PRINT ("\r\nR_GPT_Start API failed\r\n");
                return(err);
            }
            else
            {
                APP_PRINT("\r\nStarted Timer2 in PWM Mode\r\n");
            }

            APP_PRINT("Enter any Key to Disable GPT output pins using POEG software API\r\n");
            while(true)
            {
                if (APP_CHECK_DATA)
                {
                    APP_READ(rByte);
                    /* Disable POEG1 GPT output pins using POEG software API */
                    err = R_POEG_OutputDisable(&g_poeg1_ctrl);
                    break;
                }
            }
            /* Handle error */
            if (FSP_SUCCESS != err)
            {
                APP_ERR_PRINT("\r\nPOEG Output disable API failed\r\n");
            }
            APP_PRINT("\r\nPOEG output disable using software API successful\r\n");
            R_IOPORT_PinWrite(&g_ioport_ctrl, LED_PIN_POEG1, BSP_IO_LEVEL_HIGH);
            break;
        }

        /* POEG_OUTPUT_DISABLE_REQUEST_FROM_GPT - Disables GPT using output-disable
         * request from the GPT */
        case POEG_OUTPUT_DISABLE_REQUEST_FROM_GPT:
        {
            /* Start PWM Timer */
            err = R_GPT_Start(&g_timer_pwm1_ctrl);
            /* Handle error */
            if (FSP_SUCCESS != err)
            {
                APP_ERR_PRINT ("\r\nR_GPT_Start API failed\r\n");
                return(err);
            }
            else
            {
                APP_PRINT("\r\nStarted Timer1 in PWM Mode\r\n");
            }
            APP_PRINT("\r\nEnter any Key to Disable GPT Timer1 output\r\n");
            while(true)
            {
                if (APP_CHECK_DATA)
                {
                    APP_READ(rByte);
                    break;
                }
            }
            g_mode_flag     = POEG_OUTPUT_DISABLE_REQUEST_FROM_GPT;

            /* Enable same time output level disable request .*/
            R_GPT4->GTINTAD_b.GRPABH = 1;
            R_GPT4->GTINTAD_b.GRPABL = 1;

            APP_PRINT("\r\nPOEG output disable on GPT output level successful\r\n");
            R_IOPORT_PinWrite(&g_ioport_ctrl, LED_PIN_POEG0, BSP_IO_LEVEL_HIGH);
            /* Disable same time output level disable request .*/
            R_GPT4->GTINTAD_b.GRPABH = 0;
            R_GPT4->GTINTAD_b.GRPABL = 0;

            break;
        }

        /* POEG_RESET - Resets the POEG status */
        case  POEG_RESET:
        {
            err = reset_poeg_module() ;
            /* Handle error */
            if (FSP_SUCCESS != err)
            {
                APP_ERR_PRINT("\r\nFailed to reset POEG with error code: 0x%x",err);
            }
            break;
        }

        default:
        {
            APP_PRINT("\r\nInvalid input, Please enter the value between 1-4\r\n");
            break;
        }
    }
    return err;
}


/*******************************************************************************************************************//**
 * @brief       This function is used for POEG Channel0 callback to disable the IRQ and set the Mode flags
 * @param[in]   poeg_callback_args_t * p_arg
 * @return      None
 **********************************************************************************************************************/
void channel0_user_callback (poeg_callback_args_t * p_args)
{
    FSP_PARAMETER_NOT_USED(p_args);
    if(POEG_OUTPUT_DISABLE_REQUEST_FROM_GPT == g_mode_flag)
    {
        APP_PRINT("\r\nInterrupt occur in GPT OUTPUT LEVEL Mode\r\n");
        g_interrupt_output_level_flag = SET_FLAG;
    }

    /* If the POEG0 cannot be reset, disable the POEG0 interrupt to prevent
     * it from firing continuously */
    R_BSP_IrqDisable(POEG_GROUP0_IRQn);
}


/*******************************************************************************************************************//**
 * @brief       This function is used for POEG Channel1 callback to disable the IRQ and set the Mode flag
 * @param[in]   poeg_callback_args_t * p_arg
 * @return      None
 **********************************************************************************************************************/
void channel1_user_callback(poeg_callback_args_t * p_args)
{
    FSP_PARAMETER_NOT_USED(p_args);
    if (POEG_TRIGGER_ON_GTETRG_INPUT_PIN_LEVEL == g_mode_flag)
    {
        APP_PRINT("\r\nInterrupt occur in Pin Trigger Mode\r\n");
        g_interrupt_pin_trigger_flag = SET_FLAG;
    }

    /* If the POEG1 cannot be reset, disable the POEG1 interrupt to prevent
     * it from firing continuously */
    R_BSP_IrqDisable(POEG_GROUP1_IRQn);
}

/*******************************************************************************************************************//**
 * @brief       reset_poeg_module
 * @param[in]   None
 * @retval      FSP_SUCCESS                  Upon successful POEG Reset
 * @retval      Any Other Error code apart from FSP_SUCCESS  Upon Unsuccessful
 **********************************************************************************************************************/
fsp_err_t reset_poeg_module(void)
{
    fsp_err_t err = FSP_SUCCESS;

    /* Variable to store user input */
    uint8_t rByte[BUFFER_SIZE_DOWN] = {NULL_CHAR};
    uint8_t converted_rtt_input = RESET_VALUE;

    APP_PRINT(RESET_MENU_INFO);
    /* Process input only when User has provided one */
    while(!APP_CHECK_DATA);
    if (APP_CHECK_DATA)
    {
        APP_READ(rByte);
        converted_rtt_input = (uint8_t)atoi((char *)rByte);
    }
    switch (converted_rtt_input)
    {
        case POEG_CHANNEL_0:
        {
            /* Invert GTIOCB and apply it to GTIOCA */
            uint32_t gtiob = g_timer_pwm1_ctrl.p_reg->GTIOR_b.GTIOB;
            uint32_t inverted_gtiob = (~gtiob) & R_GPT0_GTIOR_GTIOA_Msk;

            /* Apply the inverted configuration safely */
            g_timer_pwm1_ctrl.p_reg->GTIOR_b.GTIOA = (uint8_t)(inverted_gtiob & R_GPT0_GTIOR_GTIOA_Msk);

            /* GTIOR changes take effect after the next cycle end. */
            while (g_timer_pwm1_ctrl.p_reg->GTCNT < g_timer_pwm1_cfg.period_counts - 1)
            {
                ;
            }

            do
            {
                err = R_POEG_Reset(&g_poeg0_ctrl);
            } while (FSP_SUCCESS != err);

            APP_PRINT("\r\n RESET POEG 0 successful\r\n");
            R_IOPORT_PinWrite(&g_ioport_ctrl, LED_PIN_POEG0, BSP_IO_LEVEL_LOW);
            g_interrupt_output_level_flag = CLEAR_FLAG;
            break;
        }

        case POEG_CHANNEL_1:
        {
            /* Invert GTIOCB and apply it to GTIOCA */
            uint32_t gtiob = g_timer_pwm2_ctrl.p_reg->GTIOR_b.GTIOB;
            uint32_t inverted_gtiob = (~gtiob) & R_GPT0_GTIOR_GTIOA_Msk;

            /* Apply the inverted configuration safely */
            g_timer_pwm2_ctrl.p_reg->GTIOR_b.GTIOA = (uint8_t)(inverted_gtiob & R_GPT0_GTIOR_GTIOA_Msk);

            /* GTIOR changes take effect after the next cycle end. */
            while (g_timer_pwm2_ctrl.p_reg->GTCNT < g_timer_pwm2_cfg.period_counts - 1)
            {
                ;
            }

            do
            {
                err = R_POEG_Reset(&g_poeg1_ctrl);
            } while (FSP_SUCCESS != err);

            APP_PRINT("\r\n RESET POEG 1 successful\r\n");
            R_IOPORT_PinWrite(&g_ioport_ctrl, LED_PIN_POEG1, BSP_IO_LEVEL_LOW);
            g_interrupt_pin_trigger_flag = CLEAR_FLAG;
            break;
        }

        default:
        {
            APP_PRINT("\r\nInvalid input, Please enter the value between 1-2\r\n");
            break;
        }
    }
    return err;
}

/*******************************************************************************************************************//**
 * @brief       This function is to initialize state of LED pins.
 * @param[in]   None
 * @return      None
 **********************************************************************************************************************/
static void led_pin_initialisation(void)
{
    R_IOPORT_PinWrite(&g_ioport_ctrl, (bsp_io_port_pin_t) g_leds.p_leds[LED_LED0], BSP_IO_LEVEL_LOW);
    R_IOPORT_PinWrite(&g_ioport_ctrl, (bsp_io_port_pin_t) g_leds.p_leds[LED_LED1], BSP_IO_LEVEL_LOW);
}

/*******************************************************************************************************************//**
 * This function is called at various points during the startup process.  This implementation uses the event that is
 * called right before main() to set up the pins.
 *
 * @param[in]  event    Where at in the start up process the code is currently at
 **********************************************************************************************************************/
void R_BSP_WarmStart (bsp_warm_start_event_t event)
{
    if (BSP_WARM_START_RESET == event)
    {
    }

    if (BSP_WARM_START_POST_C == event)
    {
        /* C runtime environment and system clocks are setup. */

        /* Configure pins. */
        R_IOPORT_Open(&IOPORT_CFG_CTRL, &IOPORT_CFG_NAME);

#if defined(BSP_FEATURE_BSP_HAS_CM33BOOT_SUPPORT) && (BSP_FEATURE_BSP_HAS_CM33BOOT_SUPPORT == 1)
        pd_all_on_preproc();

        /* Initialization for CM33 coldboot */
        if (R_SYSC->SYS_LSI_MODE_b.STAT_BOOTSELECTER == 0)
        {
            /* PD_AWO -> PD_ALL_ON */
            pd_all_on();
        }
#endif

        /* Allow access to IP beyond AXI */
        pd_all_on_postproc_axi();

#if defined(BSP_FEATURE_BSP_HAS_CM33BOOT_SUPPORT) && (BSP_FEATURE_BSP_HAS_CM33BOOT_SUPPORT == 1)
        pd_all_on_postproc();

 #if BSP_CFG_MCU_CLOCK_INIT
        pll_init_other();
 #endif

        xspi_open();

 #if BSP_CFG_MCU_LAUNCH_CR8

        /* Release reset of CR8(Core0, Core1) and load dummy program to SRAM(RCPU) */
        release_reset_cr8();
 #endif
 #if BSP_CFG_MCU_LAUNCH_CA55

        /* Load CA55 program to SRAM(ACPU) */
        load_ca55_prog();

        xspi_close();

        /* Release reset of CA55(Core0) */
        release_reset_ca55();
 #endif
#endif
    }
}
