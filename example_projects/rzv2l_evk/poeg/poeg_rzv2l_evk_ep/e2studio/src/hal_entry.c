/***********************************************************************************************************************
 * File Name    : hal_entry.c
 * Description  : Contains data structures and functions used in hal_entry.c.
 **********************************************************************************************************************/
/*
 * Copyright (c) 2020 - 2024 Renesas Electronics Corporation and/or its affiliates
 * 
 * SPDX-License-Identifier: BSD-3-Clause
 */
#include "hal_data.h"
#include "common_utils.h"
#include "poeg_ep.h"

FSP_CPP_HEADER
void R_BSP_WarmStart(bsp_warm_start_event_t event);
FSP_CPP_FOOTER

/* Global variable */
uint8_t g_num_bytes = RESET_VALUE;
static volatile uint8_t g_interrupt_pin_trigger_flag = RESET_VALUE;
static volatile uint8_t g_interrupt_output_level_flag = RESET_VALUE;
static volatile uint8_t g_mode_flag = RESET_VALUE;

/* Structure with LED information for board. */
const bsp_leds_t g_leds =
{
    .led_count = (uint16_t) ((sizeof(g_prv_leds)) / (sizeof(g_prv_leds[0]))),
    .p_leds    = &g_prv_leds[0]
};

/* User defined function */
static void led_pin_initialisation(void);

/*******************************************************************************************************************//**
 * main() is generated by the Configuration editor and is used to generate threads if an RTOS is used.  This function
 * is called by main() when no RTOS is used.
 **********************************************************************************************************************/
void hal_entry(void)
{
    fsp_err_t err = FSP_SUCCESS;
    fsp_pack_version_t version = {RESET_VALUE};

    /* Initialization of LED Pins*/
    led_pin_initialisation();

    /* version get API for FLEX pack information */
    R_FSP_VersionGet(&version);

    /* Example Project information printed on the Console */
    APP_PRINT(BANNER_INFO, EP_VERSION, version.major, version.minor, version.patch);
    APP_PRINT(EP_INFO);

    /* Initialize the POEG0 */
    err = init_poeg0_module();
    /* Handle error */
    if(FSP_SUCCESS != err)
    {
        APP_ERR_PRINT("\r\nPOEG0 initialization for GPT output level mode failed\r\n");
        APP_ERR_TRAP(err);
    }
    else
    {
        APP_PRINT("\r\nPOEG0 initialized successfully for GPT output level mode\r\n");
    }

    /* Initialize the POEG1 */
    err = init_poeg1_module();
    /* Handle error */
    if(FSP_SUCCESS != err)
    {
        APP_ERR_PRINT("\r\nPOEG1 initialization for software api failed\r\n");
        APP_ERR_TRAP(err);
    }
    else
    {
        APP_PRINT("POEG1 initialized successfully for software api\r\n");
    }

    /* Initialize the Timer1 in PWM mode */
    err = init_gpt_timer_pwm1();
    /* Handle error */
    if(FSP_SUCCESS != err)
    {
        APP_ERR_PRINT("\r\nTIMER1 start failed\r\n");
        /*Close PWM Timer instance */
        deinit_gpt_timer(&g_timer_pwm1_ctrl);
        APP_ERR_TRAP(err);
    }
    else
    {
        APP_PRINT("GPT Timer1 initialized successfully for PWM mode\r\n");
    }

    /* Initialize the Timer2 in PWM mode */
    err = init_gpt_timer_pwm2();
    /* Handle error */
    if(FSP_SUCCESS != err)
    {
        APP_ERR_PRINT("\r\nGPT TIMER2 start failed\r\n");
        deinit_gpt_timer(&g_timer_pwm2_ctrl);
        APP_ERR_TRAP(err);
    }
    else
    {
        APP_PRINT("GPT Timer2 initialized successfully for PWM mode\r\n");
    }

    while(true)
    {
        APP_PRINT(MENU_INFO);
        /* Process input only when User has provided one */
        while(!APP_CHECK_DATA);
        if (APP_CHECK_DATA)
        {
            poeg_ouput_disable_and_reset_options();
        }
    }
}

/*******************************************************************************************************************//**
 * @brief This function reads the command(input) for RTT and processes the command for poeg output disable.
 *
 * @param[in] None
 * @retval    FSP_SUCCESS                  Upon successful
 * @retval    Any Other Error code apart from FSP_SUCCESS  Upon Unsuccessful
 **********************************************************************************************************************/
fsp_err_t poeg_ouput_disable_and_reset_options(void)
{
    fsp_err_t err = FSP_SUCCESS;
    /* Variable to store user input */
    uint8_t rByte[BUFFER_SIZE_DOWN] = {NULL_CHAR};
    uint8_t converted_rtt_input = RESET_VALUE;

    APP_READ(rByte);
    /* User input selection */
    converted_rtt_input = (uint8_t)atoi((char *)rByte);

    switch (converted_rtt_input)
    {
        /* POEG_OUTPUT_DISABLE_SOFTWARE_API - Disable GPT output pins using POEG software API */
        case POEG_OUTPUT_DISABLE_SOFTWARE_API:
        {
            /* Start PWM Timer */
            err = R_GPT_Start(&g_timer_pwm2_ctrl);
            /* Handle error */
            if (FSP_SUCCESS != err)
            {
                APP_ERR_PRINT ("\r\nR_GPT_Start API failed\r\n");
                return(err);
            }
            else
            {
                APP_PRINT("\r\nStarted Timer2 in PWM Mode\r\n");
            }

            APP_PRINT("Enter any Key to Disable GPT output pins using POEG software API\r\n");
            while(true)
            {
                if (APP_CHECK_DATA)
                {
                    APP_READ(rByte);
                    /* Disable POEG1 GPT output pins using POEG software API */
                    err = R_POEG_OutputDisable(&g_poeg1_ctrl);
                    break;
                }
            }
            /* Handle error */
            if (FSP_SUCCESS != err)
            {
                APP_ERR_PRINT("\r\nPOEG Output disable API failed\r\n");
            }
            APP_PRINT("\r\nPOEG output disable using software API successful\r\n");
            R_IOPORT_PinWrite(&g_ioport_ctrl, LED_PIN_POEG1, BSP_IO_LEVEL_HIGH);
            break;
        }

        /* POEG_OUTPUT_DISABLE_REQUEST_FROM_GPT - Disables GPT using output-disable
         * request from the GPT */
        case POEG_OUTPUT_DISABLE_REQUEST_FROM_GPT:
        {
            /* Start PWM Timer */
            err = R_GPT_Start(&g_timer_pwm1_ctrl);
            /* Handle error */
            if (FSP_SUCCESS != err)
            {
                APP_ERR_PRINT ("\r\nR_GPT_Start API failed\r\n");
                return(err);
            }
            else
            {
                APP_PRINT("\r\nStarted Timer1 in PWM Mode\r\n");
            }
            APP_PRINT("\r\nEnter any Key to Disable GPT Timer1 output\r\n");
            while(true)
            {
                if (APP_CHECK_DATA)
                {
                    APP_READ(rByte);
                    break;
                }
            }
            g_mode_flag     = POEG_OUTPUT_DISABLE_REQUEST_FROM_GPT;

            /* Enable same time output level disable request .*/
            R_GPT4->GTINTAD_b.GRPABH = 1;
            R_GPT4->GTINTAD_b.GRPABL = 1;

            APP_PRINT("\r\nPOEG output disable on GPT output level successful\r\n");
            R_IOPORT_PinWrite(&g_ioport_ctrl, LED_PIN_POEG0, BSP_IO_LEVEL_HIGH);
            /* Disable same time output level disable request .*/
            R_GPT4->GTINTAD_b.GRPABH = 0;
            R_GPT4->GTINTAD_b.GRPABL = 0;

            break;
        }

        /* POEG_RESET - Resets the POEG status */
        case  POEG_RESET:
        {
            err = reset_poeg_module() ;
            /* Handle error */
            if (FSP_SUCCESS != err)
            {
                APP_ERR_PRINT("\r\nFailed to reset POEG with error code: 0x%x",err);
            }
            break;
        }

        default:
        {
            APP_PRINT("\r\nInvalid input, Please enter the value between 1-3\r\n");
            break;
        }
    }
    return err;
}


/*******************************************************************************************************************//**
 * @brief       This function is used for POEG Channel0 callback to disable the IRQ and set the Mode flags
 * @param[in]   poeg_callback_args_t * p_arg
 * @return      None
 **********************************************************************************************************************/
void channel0_user_callback (poeg_callback_args_t * p_args)
{
    FSP_PARAMETER_NOT_USED(p_args);

    if(POEG_OUTPUT_DISABLE_REQUEST_FROM_GPT == g_mode_flag)
    {
        APP_PRINT("\r\nInterrupt occur in GPT OUTPUT LEVEL Mode\r\n");
        g_interrupt_output_level_flag = SET_FLAG;
    }

    /* If the POEG0 cannot be reset, disable the POEG0 interrupt to prevent
     * it from firing continuously */
    NVIC_DisableIRQ(POEG_GROUP0_IRQn);
}

/*******************************************************************************************************************//**
 * @brief       reset_poeg_module
 * @param[in]   None
 * @retval      FSP_SUCCESS                  Upon successful POEG Reset
 * @retval      Any Other Error code apart from FSP_SUCCESS  Upon Unsuccessful
 **********************************************************************************************************************/
fsp_err_t reset_poeg_module(void)
{
    fsp_err_t err = FSP_SUCCESS;

    /* Variable to store user input */
    uint8_t rByte[BUFFER_SIZE_DOWN] = {NULL_CHAR};
    uint8_t converted_rtt_input = RESET_VALUE;

    APP_PRINT(RESET_MENU_INFO);
    /* Process input only when User has provided one */
    while(!APP_CHECK_DATA);
    if (APP_CHECK_DATA)
    {
        APP_READ(rByte);
        converted_rtt_input = (uint8_t)atoi((char *)rByte);
    }
    switch (converted_rtt_input)
    {
        case POEG_CHANNEL_0:
        {
            /* Wait until the GPT status flags are all 0 before resetting. */
            while((R_GPT4->GTST_b.DTEF != 0) || (R_GPT4->GTST_b.OABHF != 0) || (R_GPT4->GTST_b.OABLF != 0))
            {
                ;
            }
            err = R_POEG_Reset(&g_poeg0_ctrl);
            /* Handle error */
            if (FSP_SUCCESS != err)
            {
                APP_ERR_PRINT("\r\n POEG 0 reset failed\r\n");
                return(err);
            }
            APP_PRINT("\r\n RESET POEG 0 successful\r\n");
            R_IOPORT_PinWrite(&g_ioport_ctrl, LED_PIN_POEG0, BSP_IO_LEVEL_LOW);
            g_interrupt_output_level_flag = CLEAR_FLAG;
            break;
        }

        case POEG_CHANNEL_1:
        {
            /* Wait until the GPT status flags are all 0 before resetting. */
            while((R_GPT7->GTST_b.DTEF != 0) || (R_GPT7->GTST_b.OABHF != 0) || (R_GPT7->GTST_b.OABLF != 0))
            {
                ;
            }
            err = R_POEG_Reset(&g_poeg1_ctrl);
            /* Handle error */
            if (FSP_SUCCESS != err)
            {
                APP_ERR_PRINT("\r\n POEG 1 is reset failed\r\n");
                return(err);
            }
            APP_PRINT("\r\n RESET POEG 1 successful\r\n");
            R_IOPORT_PinWrite(&g_ioport_ctrl, LED_PIN_POEG1, BSP_IO_LEVEL_LOW);
            g_interrupt_pin_trigger_flag = CLEAR_FLAG;
            break;
        }

        default:
        {
            APP_PRINT("\r\nInvalid input, Please enter the value between 1-2\r\n");
            break;
        }
    }
    return err;
}

/*******************************************************************************************************************//**
 * @brief       This function is to initialize state of LED pins.
 * @param[in]   None
 * @return      None
 **********************************************************************************************************************/
static void led_pin_initialisation(void)
{
    R_IOPORT_PinWrite(&g_ioport_ctrl, (bsp_io_port_pin_t) g_leds.p_leds[LED_LED2], BSP_IO_LEVEL_LOW);
    R_IOPORT_PinWrite(&g_ioport_ctrl, (bsp_io_port_pin_t) g_leds.p_leds[LED_LED3], BSP_IO_LEVEL_LOW);
}

/*******************************************************************************************************************//**
 * This function is called at various points during the startup process.  This implementation uses the event that is
 * called right before main() to set up the pins.
 *
 * @param[in]  event    Where at in the start up process the code is currently at
 **********************************************************************************************************************/
void R_BSP_WarmStart(bsp_warm_start_event_t event)
{
    if (BSP_WARM_START_RESET == event)
    {
    }

    if (BSP_WARM_START_POST_C == event)
    {
        /* C runtime environment and system clocks are setup. */

        /* Configure pins. */
        R_IOPORT_Open (&g_ioport_ctrl, &g_bsp_pin_cfg);
    }
}
